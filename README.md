# DummyCopilot ğŸ¤–ğŸ’»

## 1.IntroduÃ§Ã£o

Este Ã© um trabalho em progresso para facilitar/automatizar a digitaÃ§Ã£o ou uso em geral de computadores desktop. Atualmente, ele permite o usuÃ¡rio criar atalhos customizÃ¡veis e globais (no nÃ­vel do sistema operacional). Outras funcionalidades virÃ£o em breve, se Deus quiser.

### 1.1.HistÃ³ria/MotivaÃ§Ã£o

A ideia nasceu de uma motivaÃ§Ã£o muito simples: Sendo um brasileiro e usando teclados ABNT2, quando tive meu primeiro notebook com teclado padrÃ£o US, a adaptaÃ§Ã£o foi muito ruim. Sendo ainda um leigo, eu nÃ£o sabia da existÃªncia do layout US internacional (que permitia essas acentuaÃ§Ãµes do alfabeto portuguÃªs). EntÃ£o, por volta de 2016 eu escrevi a primeira versÃ£o desse programa, simplesmente para digitar caracteres como "Ã§", "Ãª".

Infelizmente, na Ã©poca eu nÃ£o tinha por hÃ¡bito fazer o push dos meus cÃ³digos no github, entÃ£o nÃ£o tenho o histÃ³rico do cÃ³digo dessa Ã©poca versionado.

DaÃ­, ainda que essa fosse uma motivaÃ§Ã£o um tanto quanto inÃºtil, pois mais tarde eu acabei descobrindo o layout US internacional que me permitia essas acentuaÃ§Ãµes, outros _cases_ interessantes me levaram a dar sequÃªncia no projeto. Em geral essas motivaÃ§Ãµes foram muito na linha de evitar a digitaÃ§Ã£o de textos longos que eu nÃ£o me lembrava de cabeÃ§a, ou que eu simplesmente tinha preguiÃ§a de digitÃ¡-los. Por exemplo:

- Sempre que eu precisava fazer o push de uma branch, o git me pedia para digitar um `git push --set-upstream origin BRANCH_NAME`. Isso me incomodava muito, eu nÃ£o queria ter que digitar isso, e tbm achava chato copiar o comando do terminal para colÃ¡-lo logo abaixo. Na minha cabeÃ§a, se o git jÃ¡ sabia que era uma branch nova, eu deveria simplesmente poder digitar um simples `git push` e ele seguir o fluxo do comando que ele mesmo me sugeriu. Enfim, eu atÃ© mesmo criei um atalho no VSCode para isso, mas ainda me incomodava o fato de que se eu estivesse num terminal fora do VSCode esse atalho nÃ£o funcionaria.
- Diversos outros exemplos nessa linha. Por exemplo, ao me candidatar pra vagas, os formulÃ¡rios grandes pedindo informaÃ§Ãµes bem comuns (e tendo o input HTML sem sugestÃµes), me fazendo digitar diversas vezes informaÃ§Ãµes como 'email', 'linkedin' e por aÃ­ vai.

Diante disso, eu ficava muito encucado pensando: Eu realmente preciso de um gerenciador de atalhos que funcione no OS, seja num terminal, numa pÃ¡gina web ou o que for. Quando eu for preencher um formulÃ¡rio de vagas, eu quero digitar por exemplo algo como `. e m l ctrl` e ter o email todo digitado. Ao ter que fazer um git push de uma branch nova, eu quero digitar um `. g p ctrl` e ter o comando digitado bem na minha frente. Assim, essa foi a maior motivaÃ§Ã£o e que me fez seguir com o projeto.

Outras motivaÃ§Ãµes surgiram, como um analytics de como Ã© o meu uso do teclado, velocidade mÃ©dia de digitaÃ§Ã£o e coisas do tipo. Ou ainda, por exemplo, replicar via software funcionalidades de teclados como o `ZFA Planck EZ`. SÃ£o teclados caros, porÃ©m com nÃ­vel de personalizaÃ§Ã£o absurda; Ã© possÃ­vel atÃ© mesmo controlar o mouse pelas teclas do teclado; e, percebi que grande parte dessas funcionalidades poderiam ser reproduzidas pelo **DummyCopilot**, sem a necessidade de adquirir um hardware desse calibre.

Em outubro de 2022 eu reescrevi esse programa usando a stack NodeJS/Typescript. A primeira versÃ£o de 2016 eu havia feito em Java. Essa versÃ£o de 2022, contudo, ficou muito ruim. Para fazer o setup da aplicaÃ§Ã£o, era preciso instalar diversas bibliotecas, alÃ©m de ter que se fazer alguns ajustes no prÃ³prio cÃ³digo de acordo com o seu hardware. E, essa versÃ£o tambÃ©m sÃ³ dava suporte pra Linux. Ela pode ser encontrada neste [repositÃ³rio](https://github.com/PauloIVM/-DEPRECATED--dummy-copilot-node), mas adianto que se for tentar rodar esse cÃ³digo em Typescript, terÃ¡ muita dor de cabeÃ§a. Eu mesmo desisti num momento que precisei trocar de mÃ¡quina e nÃ£o consegui fazer o setup em um PC com ambiente mais atualizado.

Em 2023 eu voltei Ã s origens, reescrevendo o programa em Java, que se encontra aqui. Apesar deu trabalhar com Typescript no dia-a-dia, preciso confessar que pra aplicaÃ§Ãµes Desktop o Java ainda Ã© infinitamente superior. O setup da aplicaÃ§Ã£o ficou infinitamente mais simples, com compatibilidade para a maioria dos sistemas operacionais. 

### 1.2.Origem do Nome

O nome `DummyCopilot` Ã© no sentido dele ser um copiloto 'burro'/'manequim' (tipo um manequim articulado, ele sÃ³ vai fazer exatamente o que vocÃª o configurar para fazer), mas ainda assim Ãºtil pois ele irÃ¡ funcionar independente do editor de texto, OS ou o que for.

Para usar o software tambÃ©m ficou muito simples e com boa compatibilidade nos diversos OS atuais. Seguem as explicaÃ§Ãµes no tÃ³pico de instalaÃ§Ã£o.


## 2.InstalaÃ§Ã£o

Se vocÃª nÃ£o deseja saber os detalhes da implementaÃ§Ã£o, mas apenas pegar o arquivo `.jar` e sair em usando, em breve eu devo criar uma pÃ¡gina web para disponiblizar esse arquivo. AtÃ© lÃ¡, vocÃª precisarÃ¡ gerar o `.jar` pelo cÃ³digo-fonte, ou rodar o cÃ³digo fonte em um ambiente de desenvolvimento integrado.

Para rodar o projeto em um IntelliJ, VScode ou similar, nÃ£o tem muito segredo. Basta clonar o projeto; o seu editor irÃ¡ pedir para instalar as dependÃªncias do arquivo `pom.xml`, e em seguida pasta executar a classe Main em `src/main/java/Main.class`.

Se vocÃª quiser criar o `.jar` para executar o projeto fora do editor, Ã© bem simples de fazer isso pelo seu ambiente de desenvolvimento tambÃ©m. Como eu estou usando o VScode com a extensÃ£o `Extension Pack for Java`, vou mostrar como fazer isso neste editor.

Digite:

```
ctrl+shift+p
```

SerÃ¡ aberto um input de busca, digite nele `Java: Export Jar`. O VScode pedir para vocÃª selecionar as classes necessÃ¡rias para criar o `.jar`, marque todas menos as classes de testes automatizados. Com isso serÃ¡ criado um `.jar`, que vocÃª pode movar para outras pastas e executar fora do escopo do projeto; contudo, juntamente com o `.jar`, vocÃª precisarÃ¡ mover o arquivo `shortcuts.config.json` para a mesma pasta do `.jar`.

Na pasta do `.jar`, execute pelo terminal:

```
java -jar FILE_NAME.jar
```

O projeto ainda nÃ£o tem uma interface grÃ¡fica, entÃ£o vocÃª nÃ£o conseguirÃ¡ executar o programa apenas clicando no `.jar`. Contudo, assim que for criado uma interface, para executar o `.jar` pelo clique do mouse, no OS Linux vocÃª precisarÃ¡ usar um `chmod` no arquivo para dar as devidas permissÃµes, por exemplo:

```
chmod +x FILE_NAME.jar
```

## 3.Como usar

TODO: ...

## 4.Estrutura do Projeto

O projeto tem uma estrutura baseada no Clean-Architecture; onde tentei isolar o domÃ­nio em entidades e usecases, como sendo as duas camadas de mais alto nÃ­vel, e abstraindo os demais detalhes como acessos ao OS, arquivos e etc para camadas externas de baixo nÃ­vel.

![image](./assets/CleanArchitecture.jpg)

A seguir, como ficou minha hierarquia de camadas:

```
    .....................................................
    . Main.java                                         .
    .   .............................................   .
    .   . infra                                     .   .
    .   .   .....................................   .   .
    .   .   . adapters                          .   .   .
    .   .   .   .............................   .   .   .
    .   .   .   . usecases                  .   .   .   .
    .   .   .   .   .....................   .   .   .   .
    .   .   .   .   . entities          .   .   .   .   .
    .   .   .   .   .....................   .   .   .   .
    .   .   .   .............................   .   .   .
    .   .   .....................................   .   .
    .   .............................................   .
    .....................................................
```

```
  src
    â”œâ”€â”€ Main.java
    â”œâ”€â”€ infra
       â”œâ”€â”€ composers
       â”œâ”€â”€ keylistenner
       â”œâ”€â”€ robot
       â”œâ”€â”€ shortcutsfile
       â””â”€â”€ views
    â”œâ”€â”€ adapters
       â”œâ”€â”€ keyIdAdapter
       â”œâ”€â”€ keyloggerController
       â””â”€â”€ shortcutsController
    â”œâ”€â”€ usecases
       â”œâ”€â”€ actionsExecutor
       â””â”€â”€ shortcutsEvaluator
    â””â”€â”€ entities
       â”œâ”€â”€ action
       â”œâ”€â”€ clickType
       â”œâ”€â”€ keyEvent
       â”œâ”€â”€ keyId
       â””â”€â”€ shortcut
```

### 4.1.Entities (Business Rules)

Estes sÃ£o os `objetos de negÃ³cio` da aplicaÃ§Ã£o. Todas as regras de negÃ³cios se baseiam nestas entidades.

Esta Ã© a camada mais abstrata; nÃ£o deve ter nenhuma referÃªncia Ã  camadas mais externas, nenhuma camada alÃ©m de si prÃ³pria.

- Action;
- ClickType;
- KeyId;
- KeyEvent;
- Shortcut;

A `Action` representa uma aÃ§Ã£o que o programa deve executar. Essas aÃ§Ãµes fazem parte da entidade `Shortcut`; cada atalho funciona baseado num trigger e numa respectiva aÃ§Ã£o.

O `ClickType` Ã© o tipo de clique que pode ser feito pelo user. Basicamente, o user pode pressionar ou soltar uma tecla.

O `KeyId` Ã© a entidade que relaciona cada tecla a um cÃ³digo inteiro.

O `KeyEvent` Ã© uma uniÃ£o do `KeyId` e `ClickType`. Assim, sempre que uma tecla for solta ou pressionada, um `KeyEvent` poderÃ¡ ser usado para representar este evento.

Por fim, a entidade `Shortcut` Ã© uma uniÃ£o das demais entidades. Esta entidade representa um atalho, com um trigger, que nada mais Ã© do que uma lista de `KeyEvent`; e, este atalho possui uma lista de `Action` para executar quando for disparado.

### 4.2.Usecases (Application Business Rules)

Aqui temos as principais regras de negÃ³cio (por enquanto poucas). Esta camada tem a liberdade de importar e manipular as entidades, para assim criar as regras de negÃ³cio.

- ActionsExecutor;
- ShortcutsEvaluator;

O `ActionsExecutor` Ã© responsÃ¡vel por executar todas as entidades `actions` que possam existir, baseado num identificador de cada respectiva action.

Idealmente, o bom seria se o `ActionsExecutor` nÃ£o conhecesse nem mesmo a ideia de uma estrutura de uma camada superior, muito menos ter qualquer acoplamento com classes ou interfaces de camadas superiores. Contudo, esse Ã© um exemplo em que fica difÃ­cil modelar essa regra de negÃ³cio sem pressupor algo na infra que execute essas aÃ§Ãµes no sistema. Assim, nÃ³s podemos fazer uso da **inversÃ£o de dependÃªncia**; O prÃ³prio `ActionsExecutor` irÃ¡ especificar um `IRobot` genÃ©rico; e a camada de `infra` precisarÃ¡ declarar um `Robot` que implemente o `IRobot` especificado na camada `usecases`. Desta forma, a **Regra da DependÃªncia** do clean-architecture nÃ£o Ã© violada.

O `ShortcutsEvaluator` Ã© responsÃ¡vel por, baseado em uma lista de atalhos e numa entrada de teclas clicadas, nos retornar se um atalho foi disparado ou nÃ£o.

### 4.3.Adapters (Interface Adapters)

Esta camada faz uma ponte entre a infra e os usecases. Aqui por hora temos adapters e controllers.

- KeyIdAdapter;
- KeyloggerController;
- ShortcutsController;

O `KeyIdAdapter` Ã© responsÃ¡vel por mapear a entidade `KeyId` para texto e vice-versa; sendo Ãºtil em especial para representar visualmente os atalhos num json ou no terminal.

O `KeyloggerController` Ã© responsÃ¡vel por 'casar' um `IKeylistenner` (que serÃ¡ declarado na camada de infra, novamente a inversÃ£o de dependÃªncia) com o adapter `KeyIdAdapter` e a entidade `KeyEvent`; e, expor uma function para ser executada sempre que uma tecla for clicada.

O `ShortcutsController` Ã© responsÃ¡vel por 'casar' os usecases `ActionsExecutor` e `ShortcutsEvaluator` com um `IKeylistenner`. Para isso ele tambÃ©m precisara ter uma entrada de quais sÃ£o os atalhos do user, que vÃªm pela interface `IShortcutsFileParser`; e tambÃ©m possui algumas outras dependÃªncias de camadas internas que se fizeram necessÃ¡rias para gerenciar tudo isso. O objetivo desse controller Ã© aproximar ao mÃ¡ximo o uso do sistema de atalhos da infra, mas sem implementar nada ainda da camada de infra.

### 4.4.Infra (Libs, OS, Drivers...)

Esta camada jÃ¡ Ã© onde fica a implementaÃ§Ã£o concreta das classes de mais baixo nÃ­vel, que irÃ£o ler arquivos, interagir com o OS, criar interfaces grÃ¡ficas e etc.

- KeyListenner;
- Robot;
- ShortcutsFile;
- composers;
- views (CLI);

O `KeyListenner` Ã© responsÃ¡vel por 'ouvir' o teclado do user. Cada tecla clicada irÃ¡ disparar um mÃ©todo de um objeto dessa classe. Para criar essa classe, eu precisei utilizar um lib externa, que ficou completamente isolada graÃ§as Ã s boas prÃ¡ticas sugeridas no clean-arch. Como essa lib possui um mapeamento de teclas distinto do que eu estou usando, esta implementaÃ§Ã£o do `KeyListenner` vai ter seu prÃ³prio adapter convertendo os cÃ³digos das teclas da lib para as representaÃ§Ãµes das teclas no meu domÃ­nio (`KeyId`, `ClickType` e `KeyEvent`).

O `Robot` Ã© responsÃ¡vel por fazer com que a aplicaÃ§Ã£o consiga teclar algo, mover o mouse e etc no PC do usuÃ¡rio, sem que o usuÃ¡rio mesmo tenha feito isso pelo seu prÃ³rpio teclado ou mouse. Esta Ã© uma dependÃªncia do prÃ³prio Java. HÃ¡ quem diga que nÃ£o seria entÃ£o necessÃ¡rio isolÃ¡-la na camada `infra`. Contudo, quis fazer assim, pois entendi que isto deixaria as regras de negÃ³cios mais puras.

O `ShortcutsFile` Ã© responsÃ¡vel por pegar um arquivo json e convertÃª-lo para uma lista de `Shortcut`. Muito em breve ele tambÃ©m ganharÃ¡ responsabilidades de inserir atalhos no json, o caminho contrÃ¡rio.

As `view` sÃ£o as aplicaÃ§Ãµes de mais baixo nÃ­vel, que o usuÃ¡rio terÃ¡ contato. Por hora, tenho apenas uma CLI (command-line interface). Para a view funcionar, em tese ela precisa pegar outras estruturas da camada `infra`, instanciÃ¡-las, e em seguida instanciar algum controller passando essas dependÃªncias de `infra` para o controller. Para nÃ£o ficar muito complexo o build de um controller dentro da view, dentro da camada `infra` eu criei tambÃ©m o package `composers`, que nada mais Ã© do que builders dos controllers, que injetam todas as dependÃªncias de infra; como esses composers estÃ£o na camada de `infra`, eles nÃ£o violam a **Regra da DependÃªncia** por conhecerem a implementaÃ§Ã£o concreta de tais elementos.

## 5.Planejamento de prÃ³ximos passos:

- Criar mais testes automatizados;
- Conferir a visibilidade dos pacotes, mÃ©todos public desnecessÃ¡rios;
- Criar feature para inserir um atalho pelo terminal;
- Caso nÃ£o exista um arquivo de configuraÃ§Ãµes, gerar automaticamente;
- Criar feature para permitir mover o mouse pelo teclado; ex.:
    { "trigger": "ctrl+space m", "actions": [{ "type": "setMode", "mode": "mouse" }] }
    {
        "trigger": "left", "when": { "mode": "mouse" },
        "actions": [{"type": "mouseMove", "direction": "left", "px": 10 }]
    }
- Criar interface grÃ¡fica;
- Criar um analytics que me mostra dados como: mÃ©dia de velocidade de digitÃ§Ã£o ao longo dos dias; palavras mais digitadas; atalhos existentes que poderiam estar sendo usados e nÃ£o foram; etc... 

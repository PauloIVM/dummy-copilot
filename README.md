# DummyCopilot ü§ñüíª

## 1. Introdu√ß√£o

Este √© um trabalho em progresso para facilitar/automatizar a digita√ß√£o e o uso geral de computadores desktop. Atualmente, ele permite que o usu√°rio crie atalhos personalizados e globais (no n√≠vel do sistema operacional). Outras funcionalidades ser√£o adicionadas em breve, se Deus quiser.

### 1.1. Hist√≥ria/Motiva√ß√£o

A ideia surgiu de uma situa√ß√£o bastante simples: como brasileiro acostumado a usar teclados ABNT2, a adapta√ß√£o ao meu primeiro notebook com teclado padr√£o US foi bastante complicada. Sendo leigo na √©poca, desconhecia a exist√™ncia do layout US internacional, que permite a utiliza√ß√£o dos caracteres acentuados do alfabeto portugu√™s. Assim, por volta de 2016, desenvolvi a primeira vers√£o desse programa com o objetivo simplesmente de digitar caracteres como `√ß` e `√™`.

Infelizmente, naquela √©poca, n√£o tinha o h√°bito de fazer push dos meus c√≥digos no GitHub, ent√£o n√£o tenho o hist√≥rico do c√≥digo daquela vers√£o.

Embora essa tenha sido uma motiva√ß√£o inicial um tanto in√∫til, pois mais tarde descobri o layout US internacional que possibilitava tais acentua√ß√µes, outros casos interessantes me incentivaram a continuar com o projeto. Geralmente, essas motiva√ß√µes envolviam evitar a digita√ß√£o de textos longos que n√£o conseguia lembrar de cabe√ßa ou dos quais simplesmente sentia pregui√ßa de digitar. Por exemplo:

- Sempre que precisava fazer push de uma branch, o git solicitava a digita√ß√£o de `git push --set-upstream origin NOME_DA_BRANCH`. Isso me incomodava muito, pois n√£o queria digitar isso repetidamente e tamb√©m achava tedioso copiar o comando do terminal para col√°-lo logo abaixo. Na minha concep√ß√£o, se o git j√° identificava uma nova branch, eu deveria digitar um simples `git push` e ele seguir o fluxo do comando que ele pr√≥prio sugeriu. Cheguei a criar um atalho no VSCode para isso, por√©m ainda me incomodava o fato de que esse atalho n√£o funcionaria se estivesse em um terminal fora do VSCode.
- Diversos outros exemplos nessa linha. Por exemplo, ao me candidatar pra vagas, os formul√°rios grandes pedindo informa√ß√µes bem comuns (e tendo o input HTML sem sugest√µes), me fazendo digitar diversas vezes informa√ß√µes como 'email', 'linkedin' e por a√≠ vai.

Diante disso, questionava-me: "Realmente preciso de um gerenciador de atalhos que funcione no sistema operacional, seja no terminal, em uma p√°gina da web ou em qualquer lugar. Ao preencher um formul√°rio de vagas, gostaria de digitar algo como `. e m l ctrl` e ter meu email inserido automaticamente. Quando precisar fazer push de uma nova branch no git, gostaria de digitar `. g p ctrl` e ter o comando pronto para uso". Esta foi a principal motiva√ß√£o que me levou adiante com o projeto.

Outras motiva√ß√µes surgiram, como an√°lise do uso do teclado, velocidade m√©dia de digita√ß√£o e outras estat√≠sticas similares. Al√©m disso, desejava replicar funcionalidades de teclados como o `ZFA Planck EZ`, que s√£o caros, mas oferecem um n√≠vel de personaliza√ß√£o absurdo, permitindo at√© controlar o mouse pelas teclas do teclado. Percebi que muitas dessas funcionalidades poderiam ser reproduzidas pelo **DummyCopilot**, sem a necessidade de adquirir um hardware t√£o avan√ßado.

Em outubro de 2022, reescrevi esse programa utilizando a stack NodeJS/Typescript. A primeira vers√£o de 2016 havia sido feita em Java. No entanto, essa vers√£o de 2022 ficou muito problem√°tica. Para configurar a aplica√ß√£o, era necess√°rio instalar v√°rias bibliotecas e fazer ajustes no c√≥digo de acordo com o hardware utilizado. Al√©m disso, essa vers√£o oferecia suporte apenas para Linux. Ela pode ser encontrada neste [reposit√≥rio](https://github.com/PauloIVM/-DEPRECATED--dummy-copilot-node), mas aviso que tentar executar esse c√≥digo em Typescript resultar√° em muitas dificuldades. Eu mesmo desisti quando precisei trocar de m√°quina e n√£o consegui configurar o ambiente em um PC com sistema mais atualizado.

Em 2023, retornei √†s origens, reescrevendo o programa em Java, que pode ser encontrado aqui. Apesar de trabalhar com Typescript no dia a dia, devo confessar que para aplica√ß√µes Desktop o Java ainda √© muito superior. A configura√ß√£o da aplica√ß√£o tornou-se muito mais simples, com compatibilidade para a maioria dos sistemas operacionais. 

### 1.2. Origem do Nome

O nome `DummyCopilot` faz alus√£o a um copiloto "inerte" ou "manequim" (como um manequim articulado que far√° exatamente o que voc√™ o configurar para fazer), mas ainda assim √∫til, pois funcionar√° independentemente do editor de texto, sistema operacional ou outras vari√°veis.


## 2. Instala√ß√£o

TODO: Adicionar v√≠deo tutorial...

Caso n√£o queira saber os detalhes da implementa√ß√£o, mas apenas pegar o arquivo `.jar` e come√ßar a usar, em breve pretendo disponibilizar esse arquivo por meio de uma p√°gina web. At√© l√°, ser√° necess√°rio gerar o `.jar` a partir do c√≥digo-fonte ou executar o c√≥digo-fonte em um ambiente de desenvolvimento integrado.

Para rodar o projeto em um IntelliJ, VScode ou similar, n√£o h√° muitos segredos. Basta clonar o projeto; o seu editor solicitar√° a instala√ß√£o das depend√™ncias do arquivo `pom.xml` e, em seguida, executar a classe Main em `src/main/java/Main.class`.

Se desejar criar o `.jar` para executar o projeto fora do editor, √© bem simples fazer isso tamb√©m pelo ambiente de desenvolvimento. Como utilizo o VScode com a extens√£o `Extension Pack for Java`, mostrarei como fazer isso neste editor.

Digite:

```
ctrl+shift+p
```

Isso abrir√° uma caixa de busca; digite `Java: Export Jar` nela. O VScode solicitar√° a sele√ß√£o das classes necess√°rias para criar o `.jar`, marque todas, exceto as classes de testes automatizados. Isso criar√° um `.jar`, que poder√° ser movido para outras pastas e executado fora do contexto do projeto; no entanto, junto com o `.jar`, ser√° necess√°rio mover o arquivo `shortcuts.config.json` para a mesma pasta do `.jar`.

Na pasta do `.jar`, execute no terminal:

```
java -jar FILE_NAME.jar
```

O projeto ainda n√£o possui uma interface gr√°fica, protanto, n√£o ser√° poss√≠vel executar o programa apenas clicando no `.jar`. Contudo, quando for criada uma interface, para executar o `.jar` pelo clique do mouse, no OS Linux bastar√° usar um `chmod` no arquivo para dar as devidas permiss√µes, por exemplo:

```
chmod +x FILE_NAME.jar
```

## 3. Como usar

TODO: Adicionar v√≠deo tutorial...

Tendo feito a configura√ß√£o e executado o projeto com sucesso, voc√™ ter√° percebido a import√¢ncia do arquivo `shortcuts.config.json`. Neste arquivo, √© onde est√£o armazenados todos os seus atalhos personalizados.

Para criar um novo atalho, voc√™ mesmo pode editar o arquivo JSON, ou, voc√™ pode cadastrar um novo atalho pelo CLI. Esta segunda op√ß√£o √© a maneira mais simples e indicada; contudo, vou seguir explicando a ideia do atalho no JSON.

Cada atalho possui um `trigger` e uma lista de `actions`. Para formar a sequ√™ncia de um `trigger` de um atalho, basta considerar que a sequ√™ncia √© composta pela representa√ß√£o textual de cada tecla separada por espa√ßos. No caso de teclas pressionadas simultaneamente, √© necess√°rio utilizar o sinal `+` entre as duas teclas em vez do espa√ßo.

Por exemplo, suponhamos um `trigger` em que o usu√°rio pressiona a tecla `control`; mantendo o `control` pressionado, pressiona a tecla `espa√ßo`. Em seguida, libera tanto a tecla `espa√ßo` quanto a tecla `control`; e por fim, pressiona e solta a tecla `m`. A representa√ß√£o do `trigger` no formato de texto seria:

```
"trigger": "ctrl+space m"
```

Observe que para criar um `trigger`, √© necess√°rio conhecer a representa√ß√£o em texto de cada tecla. Para descobrir isso, voc√™ pode iniciar o CLI, selecionar a op√ß√£o `Start keylogger` e, em seguida, as teclas que voc√™ pressionar ter√£o o c√≥digo textual exibido no terminal. Um detalhe importante √© que a representa√ß√£o das teclas se baseia no layout do teclado dos EUA (US International Keyboard Layout), ent√£o os nomes das teclas podem ser um pouco diferentes dos s√≠mbolos no seu teclado; no entanto, basta copiar e colar a string indicada pelo CLI.

Depois de ter o `trigger`, agora voc√™ precisa fornecer as a√ß√µes do seu atalho. Por enquanto, temos apenas dois tipos de a√ß√µes: `paste` e `sequence`. Na lista de a√ß√µes que voc√™ fornecer√° no atalho, √© poss√≠vel combinar a√ß√µes dos dois tipos. Normalmente, voc√™ vai querer apagar algum caractere que foi utilizado para acionar a a√ß√£o e, em seguida, inserir algo ou executar uma sequ√™ncia de teclas. No exemplo abaixo, eu finalizo o atalho inicialmente com uma a√ß√£o que pressiona a tecla `backspace` para apagar a tecla `m` que foi digitada durante o trigger; em seguida, realizo um `paste` de um conte√∫do qualquer:

```
// Filename: shortcuts.config.json
[
    {
        "trigger": "ctrl+space m",
        "actions": [
            { "type": "sequence", "keys": "backspace" },
            { "type": "paste", "content": "FOO" }
        ]
    }
]
```

Repare que o `shortcuts.config.json` √© um array, e voc√™ pode adicionar quantos atalhos quiser.

## 4. Estrutura do Projeto

O projeto possui uma estrutura baseada no Clean Architecture, onde busquei isolar o dom√≠nio em entidades e casos de uso, como as camadas de n√≠vel mais alto, e abstrair os detalhes como acessos ao sistema operacional, arquivos, entre outros, para camadas externas de n√≠vel mais baixo.

![image](./assets/CleanArchitecture.jpg)

A seguir, a estrutura de camadas do projeto:

```
    .....................................................
    . Main.java                                         .
    .   .............................................   .
    .   . infra                                     .   .
    .   .   .....................................   .   .
    .   .   . adapters                          .   .   .
    .   .   .   .............................   .   .   .
    .   .   .   . usecases                  .   .   .   .
    .   .   .   .   .....................   .   .   .   .
    .   .   .   .   . entities          .   .   .   .   .
    .   .   .   .   .....................   .   .   .   .
    .   .   .   .............................   .   .   .
    .   .   .....................................   .   .
    .   .............................................   .
    .....................................................
```

```
  src
    ‚îú‚îÄ‚îÄ Main.java
    ‚îú‚îÄ‚îÄ infra
       ‚îú‚îÄ‚îÄ composers
       ‚îú‚îÄ‚îÄ keylistenner
       ‚îú‚îÄ‚îÄ robot
       ‚îú‚îÄ‚îÄ repositories
       ‚îî‚îÄ‚îÄ views
    ‚îú‚îÄ‚îÄ adapters
       ‚îú‚îÄ‚îÄ keyEventListAdapter
       ‚îî‚îÄ‚îÄ keyIdAdapter
    ‚îú‚îÄ‚îÄ usecases
       ‚îú‚îÄ‚îÄ keyEventsScanner
       ‚îú‚îÄ‚îÄ keyScanner
       ‚îú‚îÄ‚îÄ shortcutsRunner
       ‚îî‚îÄ‚îÄ shortcutsUpdater
    ‚îî‚îÄ‚îÄ entities
       ‚îú‚îÄ‚îÄ action
       ‚îú‚îÄ‚îÄ actionsExecutor
       ‚îú‚îÄ‚îÄ clickType
       ‚îú‚îÄ‚îÄ keyEvent
       ‚îú‚îÄ‚îÄ keyId
       ‚îú‚îÄ‚îÄ shortcut
       ‚îî‚îÄ‚îÄ shortcutsEvaluator
```

### 4.1. Entities (Business Rules)

Esses s√£o os `objetos de neg√≥cio` da aplica√ß√£o. Todas as regras de neg√≥cio se baseiam nessas entidades.

Esta √© a camada mais abstrata; n√£o deve conter refer√™ncias a camadas al√©m dela mesma.

### 4.2. Usecases (Application Business Rules)

Aqui est√£o as principais regras de neg√≥cio. Esta camada tem a liberdade de importar e manipular as entidades para criar as regras de neg√≥cio. A ideia √© que as classes dessas camadas se aproximem ao m√°ximo de um requisito funcional da aplica√ß√£o.

### 4.3. Adapters (Interface Adapters)

Essa camada atua como uma ponte entre a infraestrutura e os casos de uso. Na modelagem atual, essa camada n√£o necessitou de muitas implementa√ß√µes, apenas alguns adapters (ou pode chamar de parsers se preferir).

### 4.4. Infra (Libs, OS, Drivers...)

Nesta camada, encontramos a implementa√ß√£o concreta das classes de mais baixo n√≠vel, respons√°veis por ler arquivos, interagir com o sistema operacional, criar interfaces gr√°ficas, entre outras fun√ß√µes.

Aqui basicamente vamos ter as views (por enquanto apenas um CLI), a implementa√ß√£o dos repositories, libs, e alguns recursos do OS, como o Robot da awt por exemplo.

## 5. Planejamento de pr√≥ximos passos:

- A tecla 'enter' do numpad quebra a aplica√ß√£o no keylogger. N√£o apenas adicionar o mapeamento dessa tecla, mas caso uma tecla n√£o mapeada seja inserida, tratar para que a aplica√ß√£o n√£o crashe.
- Refatorar entidade 'ActionsExecutor' para algo pr√≥ximo de um Observer. Ela n√£o deve saber que existe um Robot, nem mesmo via interface. Ela deve apenas ter um subscribe pra avisar algu√©m quando uma actoin ocorrer. Da√≠ nos usecases eu posso trazer a ideia do Robot via interface. Acho que isso vai deixar a entidade mais pura.
- Criar v√≠deos explicativos;
- Criar feature para deixar as coisas mai√∫slas ou min√∫sculas; Me basear no VSCode:
    {
        "trigger": "ctrl+space u",
        "actions": [{ type: "editor", "command": "transformToUppercase" }]
    }
- Permitir buildar com um mapper para US e outro para ABNT2, ou um mapper personalizado;
- Caso n√£o exista um arquivo de configura√ß√µes, gerar automaticamente;
- Criar feature para permitir mover o mouse pelo teclado; ex.:
    { "trigger": "ctrl+space m", "actions": [{ "type": "setMode", "mode": "mouse" }] }
    {
        "trigger": "left", "when": { "mode": "mouse" },
        "actions": [{"type": "mouseMove", "direction": "left", "px": 10 }]
    }
- Deixar o CLI mais bonitinho: https://medium.com/@shubham0473/unleash-your-inner-artist-a-step-by-step-guide-to-converting-images-to-ascii-art-using-java-97860464f19a
- Criar interface gr√°fica;
- Criar um analytics que me mostra dados como: m√©dia de velocidade de digit√ß√£o ao longo dos dias; palavras mais digitadas; atalhos existentes que poderiam estar sendo usados e n√£o foram; etc... 
